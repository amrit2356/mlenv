#!/usr/bin/env bash
# MLEnv - ML Environment Manager (Modular Version)
# Version: 2.0.0

set -euo pipefail

# Detect installation location
if [[ -f "/usr/local/lib/mlenv/core/engine.sh" ]]; then
    export MLENV_LIB="/usr/local/lib/mlenv"
elif [[ -f "/usr/lib/mlenv/core/engine.sh" ]]; then
    export MLENV_LIB="/usr/lib/mlenv"
else
    # Development mode - use relative path
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    export MLENV_LIB="$(dirname "$SCRIPT_DIR")/lib/mlenv"
fi

# Verify library exists
if [[ ! -d "$MLENV_LIB" ]]; then
    echo "Error: MLEnv library not found at: $MLENV_LIB"
    exit 1
fi

# Initialize engine
source "${MLENV_LIB}/core/engine.sh"

# Global variables (from original script)
VERSION="2.0.0"
WORKDIR="$(pwd)"
PROJECT_NAME="$(basename "$WORKDIR")"
WORKDIR_HASH="$(echo "$WORKDIR" | md5sum | cut -c1-8)"
CONTAINER_NAME="mlenv-${PROJECT_NAME}-${WORKDIR_HASH}"
LOG_DIR="$WORKDIR/.mlenv"
LOG_FILE="$LOG_DIR/mlenv.log"
REQUIREMENTS_MARKER="$LOG_DIR/.requirements_installed"

# Command-line options (will be overridden by config)
IMAGE=""
REQUIREMENTS_PATH=""
FORCE_REQUIREMENTS=false
VERBOSE=false
PORTS=""
JUPYTER_PORT=""
GPU_DEVICES=""
ENV_FILE=""
MEMORY_LIMIT=""
CPU_LIMIT=""
RUN_AS_USER=true
EXEC_CMD=""

# Create log directory
mkdir -p "$LOG_DIR"

# Set log file for engine
export MLENV_LOG_FILE="$LOG_FILE"
export MLENV_LOG_DIR="$LOG_DIR"

# Commands implementation using new engine

cmd_up() {
    check_requirements_file
    
    # Check NGC authentication if needed
    if [[ -n "$IMAGE" ]] && [[ "$IMAGE" == *"nvcr.io"* ]] && [[ "$IMAGE" != *"/nvidia/"* ]]; then
        if ! ngc_auth_registry_is_authenticated; then
            error "Private NGC image requires authentication"
            info "Run: mlenv login"
            return 1
        fi
    fi
    
    vlog "Configuration:"
    vlog "  Image: ${IMAGE:-$MLENV_DEFAULT_IMAGE}"
    vlog "  Container: $CONTAINER_NAME"
    vlog "  Workdir: $WORKDIR"
    vlog "  GPUs: ${GPU_DEVICES:-$MLENV_GPU_DEVICES}"
    
    local status=$(container_get_status "$CONTAINER_NAME")
    
    case "$status" in
        running)
            info "Container already running"
            ;;
        stopped)
            log "▶ Starting existing container"
            container_start "$CONTAINER_NAME"
            success "Container started"
            ;;
        absent)
            local image="${IMAGE:-$MLENV_DEFAULT_IMAGE}"
            
            # Pull image if needed
            if ! image_exists "$image"; then
                image_pull "$image"
            fi
            
            # Create init script if running as user
            if [[ "$RUN_AS_USER" == "true" ]]; then
                container_create_init_script "$LOG_DIR"
            fi
            
            # Create devcontainer config
            if [[ "$(config_get 'devcontainer.auto_generate' 'true')" == "true" ]]; then
                devcontainer_create_config "$WORKDIR"
            fi
            
            log "▶ Creating container: $CONTAINER_NAME"
            
            # Build container args
            readarray -t container_args < <(container_build_run_args "$CONTAINER_NAME" "$image" "$WORKDIR")
            
            # Create container via adapter
            if container_create "$CONTAINER_NAME" "${container_args[@]}"; then
                success "Container created and started"
            else
                die "Failed to create container. Check logs: mlenv logs"
            fi
            ;;
    esac
    
    # Wait for container to be ready
    sleep 1
    
    # Install requirements if specified
    install_requirements
    
    success "Environment ready"
    if [[ -n "$PORTS" ]]; then
        info "Ports forwarded: $PORTS"
    fi
    info "Enter with: mlenv exec"
}

cmd_exec() {
    if ! container_is_running "$CONTAINER_NAME"; then
        die "Container not running. Start with: mlenv up"
    fi
    
    local exec_args=()
    exec_args+=("-it")
    
    # Determine user for exec
    if [[ "$RUN_AS_USER" == "true" ]]; then
        exec_args+=("--user" "$(id -u):$(id -g)")
    fi
    
    if [[ -n "$EXEC_CMD" ]]; then
        # Execute specific command
        vlog "Executing command: $EXEC_CMD"
        exec_args+=("bash" "-c" "$EXEC_CMD")
        container_exec "$CONTAINER_NAME" "${exec_args[@]}"
    else
        # Interactive bash
        exec_args+=("bash")
        container_exec "$CONTAINER_NAME" "${exec_args[@]}"
    fi
}

cmd_down() {
    if container_is_running "$CONTAINER_NAME"; then
        log "■ Stopping container"
        container_stop "$CONTAINER_NAME"
        success "Container stopped"
    else
        info "Container not running"
    fi
}

cmd_rm() {
    if container_exists "$CONTAINER_NAME"; then
        log "✖ Removing container (your code on host is safe)"
        container_remove "$CONTAINER_NAME"
        
        # Clean up markers and init script
        rm -f "$REQUIREMENTS_MARKER"
        rm -f "${LOG_DIR}/init.sh"
        
        success "Container removed"
    else
        info "Container does not exist"
    fi
}

cmd_restart() {
    cmd_down
    sleep 1
    cmd_up
}

cmd_logs() {
    if [[ -f "$LOG_FILE" ]]; then
        cat "$LOG_FILE"
    else
        info "No logs found"
    fi
}

cmd_status() {
    local status=$(container_get_status "$CONTAINER_NAME")
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Container: $CONTAINER_NAME"
    echo "Status: $status"
    echo "Workdir: $WORKDIR"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    if container_exists "$CONTAINER_NAME"; then
        echo ""
        container_list "name=${CONTAINER_NAME}"
    fi
}

cmd_login() {
    ngc_auth_registry_login ""
}

cmd_logout() {
    ngc_auth_registry_logout
}

cmd_config() {
    local subcmd="${1:-show}"
    shift || true
    
    case "$subcmd" in
        show)
            config_show
            ;;
        get)
            local key="$1"
            config_get "$key"
            ;;
        set)
            local key="$1"
            local value="$2"
            config_set "$key" "$value"
            success "Set $key = $value"
            ;;
        generate)
            local output="${1:-$HOME/.mlenvrc}"
            config_save "$output"
            ;;
        *)
            echo "Usage: mlenv config {show|get|set|generate}"
            ;;
    esac
}

cmd_version() {
    echo "MLEnv - ML Environment Manager v${VERSION}"
    echo ""
    engine_get_info
}

cmd_help() {
    cat <<EOF
MLEnv - ML Environment Manager v${VERSION}

USAGE:
  mlenv <command> [options]

COMMANDS:
  login       Authenticate with NGC
  logout      Remove NGC authentication
  up          Create/start container
  exec        Open interactive shell (or run command with -c)
  down        Stop container
  restart     Restart container
  rm          Remove container (keeps your code safe)
  status      Show container status
  logs        View debug logs
  config      Manage configuration
  version     Show version information
  help        Show this help

CONFIG COMMANDS:
  mlenv config show            Show current configuration
  mlenv config get <key>       Get config value
  mlenv config set <key> <val> Set config value
  mlenv config generate        Generate ~/.mlenvrc

OPTIONS (for 'up' command):
  --image <name>              Docker image
  --requirements <path>       Install Python requirements from file
  --force-requirements        Force reinstall requirements
  --port <mapping>            Port forwarding (e.g., "8888:8888,6006:6006")
  --gpu <devices>             GPU devices (e.g., "0,1" or "all")
  --env-file <path>           Environment variables file
  --memory <limit>            Memory limit (e.g., "16g")
  --cpus <limit>              CPU limit (e.g., "4.0")
  --no-user-mapping           Run as root instead of current user
  --verbose                   Enable verbose output

EXAMPLES:
  # Basic setup
  mlenv up
  mlenv exec

  # With configuration file
  cp $(dirname $(which mlenv))/../share/mlenv/examples/mlenvrc.example ~/.mlenvrc
  # Edit ~/.mlenvrc with your preferences
  mlenv up

  # Full setup with Jupyter
  mlenv up --requirements requirements.txt --port 8888:8888,6006:6006
  
For more information: https://github.com/your-username/mlenv
EOF
}

# Helper functions

check_requirements_file() {
    if [[ -n "$REQUIREMENTS_PATH" ]] && [[ ! -f "$REQUIREMENTS_PATH" ]]; then
        die "Requirements file not found: $REQUIREMENTS_PATH"
    fi
}

install_requirements() {
    if [[ -z "$REQUIREMENTS_PATH" ]]; then
        return 0
    fi
    
    local rel_path
    rel_path="$(realpath --relative-to="$WORKDIR" "$REQUIREMENTS_PATH")"
    
    # Check if already installed (unless force flag is set)
    if [[ "$FORCE_REQUIREMENTS" == "false" ]] && [[ -f "$REQUIREMENTS_MARKER" ]]; then
        local marker_content
        marker_content="$(cat "$REQUIREMENTS_MARKER")"
        local current_hash
        current_hash="$(md5sum "$REQUIREMENTS_PATH" | cut -d' ' -f1)"
        
        if [[ "$marker_content" == "$current_hash" ]]; then
            info "Requirements already installed (use --force-requirements to reinstall)"
            return 0
        fi
    fi
    
    log "▶ Installing requirements from: $rel_path"
    
    local exec_args=("--user" "$(id -u)")
    if docker_container_exec "$CONTAINER_NAME" "${exec_args[@]}" bash -c \
        "pip install --no-cache-dir --upgrade pip && pip install --no-cache-dir -r '/workspace/$rel_path'" >> "$LOG_FILE" 2>&1; then
        md5sum "$REQUIREMENTS_PATH" | cut -d' ' -f1 > "$REQUIREMENTS_MARKER"
        success "Requirements installed"
    else
        die "Failed to install requirements. Check logs: mlenv logs"
    fi
}

# Parse command
command="${1:-help}"
shift || true

# Parse options before initializing engine
while [[ $# -gt 0 ]]; do
    case "$1" in
        --image)
            IMAGE="$2"
            shift 2
            ;;
        --requirements)
            REQUIREMENTS_PATH="$2"
            shift 2
            ;;
        --force-requirements)
            FORCE_REQUIREMENTS=true
            shift
            ;;
        --port)
            PORTS="$2"
            shift 2
            ;;
        --gpu)
            GPU_DEVICES="$2"
            shift 2
            ;;
        --env-file)
            ENV_FILE="$2"
            shift 2
            ;;
        --memory)
            MEMORY_LIMIT="$2"
            shift 2
            ;;
        --cpus)
            CPU_LIMIT="$2"
            shift 2
            ;;
        --no-user-mapping)
            RUN_AS_USER=false
            shift
            ;;
        --verbose)
            VERBOSE=true
            export MLENV_VERBOSE=true
            shift
            ;;
        -c)
            EXEC_CMD="$2"
            shift 2
            ;;
        *)
            shift
            ;;
    esac
done

# Initialize engine
engine_init

# Override config with command-line options
[[ -n "$IMAGE" ]] && MLENV_DEFAULT_IMAGE="$IMAGE"
[[ -n "$GPU_DEVICES" ]] && export MLENV_GPU_DEVICES="$GPU_DEVICES"
[[ -n "$PORTS" ]] && export MLENV_PORTS="$PORTS"
[[ -n "$ENV_FILE" ]] && export MLENV_ENV_FILE="$ENV_FILE"
[[ -n "$MEMORY_LIMIT" ]] && export MLENV_MEMORY_LIMIT="$MEMORY_LIMIT"
[[ -n "$CPU_LIMIT" ]] && export MLENV_CPU_LIMIT="$CPU_LIMIT"
[[ -n "$RUN_AS_USER" ]] && export MLENV_RUN_AS_USER="$RUN_AS_USER"

# Execute command
case "$command" in
    login)    cmd_login ;;
    logout)   cmd_logout ;;
    up)       cmd_up ;;
    exec)     cmd_exec ;;
    down)     cmd_down ;;
    restart)  cmd_restart ;;
    rm)       cmd_rm ;;
    logs)     cmd_logs ;;
    status)   cmd_status ;;
    config)   cmd_config "$@" ;;
    version|--version|-v)  cmd_version ;;
    help|--help|-h)  cmd_help ;;
    *)
        die "Unknown command: $command. Use 'mlenv help' for usage."
        ;;
esac
